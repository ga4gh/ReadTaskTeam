@namespace("org.ga4gh.wip")

/**
A sequence graph is made progressively joining new sequence pieces, which we
call variants, into an existing graph.  This starts with a primary sequence. For
example consider the primary sequence in GRCh38 for a chromosome.  Then variants
can be joined into it, starting on a defined side of a defined base in the
existing structure, containing new sequence (potentially empty if a pure
deletion or breakpoint) and then joining back to another defined side of another
base in the current graph.

An arbitrarily complex reference graph is built this way, but we can also use
the same construction to specify individual variants from the reference.

Any base in the graph will have a unique identity defined by its variant id and
0-based position in the variant sequence.  It is oriented in the direction of
the variant sequence.

We support a context model for uniquely identifying bases in the graph.
Currently this is the UCSC left-right mapping proposal as proposed by Paten,
Haussler et al. - http://arxiv.org/abs/1404.5010
*/
protocol VariationReference {

import idl "../common.avdl";

/**
A `VariationReference` is a set of `Variant`s which typically comprise a
reference assembly, such as `GRCh38`. A `VariationReference` defines a common
graph coordinate space for comparing reference-aligned experimental data.
*/
record VariationReference {
  /** The variation reference ID. Unique in the repository. */
  string id;

  // `Variant` objects record their membership in the `VariationReference`,
  // sicne there will be a lot of them and we probably want to paginate them.

  /**
  Order-independent MD5 checksum which identifies this `VariationReference`. The
  checksum is computed by sorting all `md5checksum`s for all `Variant`s in the
  reference in ascending lexicographic order, concatenating, and taking the MD5
  of that value.
  */
  string md5checksum;

  /**
  ID from http://www.ncbi.nlm.nih.gov/taxonomy (e.g. 9606->human) indicating
  the species which this assembly is intended to model. Note that contained
  `Reference`s may specify a different `ncbiTaxonId`, as assemblies may
  contain reference sequences which do not belong to the modeled species, e.g.
  EBV in a human reference genome.
  */
  union { null, int } ncbiTaxonId = null;

  /** Optional free text description of this reference set. */
  union { null, string } description = null;

  // next information about the source of the sequences

  /** Public id of this reference set, such as `GRCh37`. */
  union { null, string } assemblyId = null;

  /** Specifies a FASTA format file/string. */
  union { null, string } sourceURI = null;

  /**
  All known corresponding accession IDs in INSDC (GenBank/ENA/DDBJ) ideally
  with a version number, e.g. `NC_000001.11`.
  */
  array<string> sourceAccessions;

  /**
  A reference set may be derived from a source if it contains
  additional sequences, or some of the sequences within it are derived
  (see the definition of `isDerived` in `Reference`).
  */
  boolean isDerived = false;
}

/**
PLUS represents forwards, or the direction of increasing coordinates, while
MINUS represents reverse-complement, or the direction of decreasing coordinates.
*/
enum VariantSide {
  PLUS,
  MINUS
}


record VariantJoinLocation {
  string variantId; // id of the variant in which this location is based
  int position;     // 0-based
  VariantSide side;
  
  /**
  MD5 of the `md5checksum` of the variant being joined onto, the position as a
  decimal string, and "+" or "-" as appropriate for the side, in that order.
  Doesn't always have to be included, really just exists for making sure that
  the MD5 of a Variant and thus a VariationReference is well-defined.
  */
  union { null, string } md5checksum = null;
}

/**
Represents a chunk of sequence (possibly joined onto other such chunks) that is
part of a reference graph.
*/
record Variant {

  /** The variant ID. Unique within the repository. */
  string id;
  
  /**
  The ID of the `VariationReference` that this variant belongs to, if any.
  */
  union { null, string } variationReferenceId = null;
  
  /**
  The ID of the `VariantSet` that this variant belongs to, if it does not belong
  to a `VariationReference`.  
  */
  union { null, string } variantSetId = null;
  
  /**
  Names for the variant, for example a RefSNP ID.
  */
  array<string> names = [];

  /**
  MD5 of the sequenceMd5checksum, the MD5 of the startJoin, and the MD5 of the
  endJoin, in that order. Note that this means a variant may not join onto
  itself, or anything that joins onto it, or this hash would not be defined.
  */
  string md5checksum;

  /**
  All known corresponding accession IDs in INSDC (GenBank/ENA/DDBJ) ideally
  with a version number, e.g. `GCF_000001405.26`.
  */
  array<string> sourceAccessions;

  /**
  Start and end locations of how this variant fits into the existing graph. May
  be null only for a primary sequence that is not joined onto any other. Note
  that the variantId for start and end may not be the same.
  */
  union { null, VariantJoinLocation } startJoin, endJoin;  
  
  /**
  The length of this variant's sequence.
  */
  long length;
  
  /**
  The sequence to insert between startJoin and endJoin. Must be set if sourceURI
  is null.  
  */
  union { null, string } sequence = null;
  
  /**
  The URI from which the sequence may be obtained, as a FASTA format file with
  one name, sequence pair. Must be set if sequence is null.
  */
  union { null, string } sourceURI = null;
  
  /**
  MD5 of the upper-case sequence excluding all whitespace characters
  (this is equivalent to SQ:M5 in SAM).
  */
  string sequenceMd5checksum;

  // For variants that are part of a reference to which new sequences (e.g.
  // reads) are being mapped, a context function must be defined in
  // referenceVariationMethods.avdl so that bases in the reads can be mapped to
  // bases in the reference variant.

  /**
  We may need to say other things about the variant, e.g. origin, dbSNP...
  */
  map<string> info = {};
}

/*
Next we show how to provide information about samples.  The core idea is to
provide Calls which each contain information about a set of Alleles (all of
which are called together as having a copy number) in a CallSet. Loosely the
allele sets correspond to rows in a VCF and the callsets to a column, but there
are some key differences.

First, we provide information separately about allele sets not sites (unary
variant model).  We can determine from the graph whether two allele sets are
incompatible in the same haplotype and hence "allelic" in the standard usage of
the term.  Note that this is a pairwise relation, not transitive. This avoids
the problems when merging sites in VCF.  Our merge semantics are simple: only
merge identical allele sets. Identity can be checked by name when sharing a
global name and definition space, or recursively by how the alleles are
constructed from global objects when scope is local.

Second, we represent phase information by separate haplotype callSets, rather
than using some sort of | or / notation or equivalent in the calls of a genotype
callSet. So genotype callSets just contain allele counts (copy number) or
dosages. Because we support sparse callSets, which we hope can be lightweight,
each piece of partial haplotype phasing (as for example supported by phase sets
in VCF) will be a separate haplotype CallSet on the same sample. Since phasing
onto haplotypes can still be ambiguous in the case of complex duplications and
transpositions, we also provide a notion of Scaffolds which are ordered,
oriented, gapped lists of Alleles that are asserted to appear on the same
molecule.
*/

/**
This metadata represents VCF header information. Includes both the field value
and the information about the field definition, to allow a VCF header to be
reconstructed.
*/
record VariantSetMetadata {
  /** The top-level key. */
  string key;

  /** The value field for simple metadata. */
  string value;

  /**
  User-provided ID field, not enforced by this API.
  Two or more pieces of structured metadata with identical
  id and key fields are considered equivalent.
  */
  string id;

  /** The type of data. */
  string type;

  /**
  The number of values that can be included in a field described by this
  metadata.
  */
  string number;

  /** A textual description of this metadata. */
  string description;

  /** Remaining structured metadata key-value pairs. */
  map<array<string>> info = {};
}

/**
A `CallSet` has calls in a `VariantSet`. Some `Variant`s belong to
`VariantSet`s, while other belong to `VariationReference`s. A `VariantSet`
belongs to a `Dataset`. The variant set is equivalent to a VCF file.
*/
record VariantSet {
  /** The variant set ID. */
  string id;

  /** The ID of the dataset this variant set belongs to. */
  string datasetId;

  /**
  The `VariationReference` on which this `VariantSet` is defined.
  */
  string variationReferenceId;

  /** The date this variant set was created in milliseconds from the epoch. */
  union { null, long } created = null;

  /**
  The time at which this variant set was last updated in milliseconds from the
  epoch.
  */
  union { null, long } updated = null;

  // We don't list all the CallSets we have calls in because we expect there to
  // be many more CallSets than VariantSets.

  /**
  The metadata associated with this variant set. This is equivalent to
  the VCF header information not already presented in first class fields.
  */
  array<VariantSetMetadata> metadata = [];
}

/**
A `Segment` is a substring of a `Variant`. 1 or more `Segment`s (possibly from
different `Variant`s) can be strung together end to end to form an `Allele`.

Note that a `Segment` can be 0-length, especially if it is representing the
entirety of a 0-length `Allele`.
*/
record Segment {
  /**
  References an id of a Variant.
  */
  string variantId;
  
  /**
  0-based start position along the `Variant`, inclusive.
  */
  long start;
  
  /**
  Number of DNA bases in the `Segment`.
  */
  long length;
    
  /**
  Orientation in which the `Segment` appears in its `Allele`.
  */     
  VariantSide side; 
}

/*
An Allele is a contigous piece of sequence that we will want to say is present
(in general at some copy number) or absent in a sample.  Very often it will just
be a single segment with the entirety of a `Variant`, but it is also common for
it to be a `Segment` of a `Variant` not overlapped by another `Variant`, or in
general any contiguous path through the sequence graph of `Variant`s.

Since `Allele`s are defined on `Variant`s, they belong to `VariantSet`s.
*/
record Allele {
  /**
  The ID of this `Allele`. If this Allele is one segment consisting of the
  entirety of a `Variant`, this is equal to the ID of that `Variant`.
  */
  string id;
  
  /**
  The `VariantSet` to which this `Allele` belongs.
  */
  string variantSetId;  

  /**
  Require that segments abut in order. Also require they are maximal, i.e. that
  consecutive elements of the array can not be replaced by a single element.
  */
  array<Segment> sequence;   
}

/**
Some CallSets reflect genotype calls, while others reflect linked haplotype
calls.
*/
enum CallSetType {
  GENOTYPE,
  HAPLOTYPE
}

/**
A `CallSet` is a collection of variant calls for a particular sample. It belongs
to a `VariantSet`. A GENOTYPE-type CallSet is approximately equivalent to one
column in VCF.
*/
record CallSet {

  /** The call set ID. */
  string id;

  /** The call set name. */
  union { null, string } name = null;

  /** The sample this call set's data was generated from. */
  union { null, string } sampleId;

  /**
  A `CallSet` must be either a genotype or a haplotype. This field specifies
  which. A HAPLOTYPE-type `CallSet` is just a bag of `Call`s on the same piece
  of DNA; there may be more than one way to traverse the graph as a single
  haplotype.
  */
  CallSetType callsetType;
  
  // For diploid genotypes the copy number of a Variant in a Call will typically
  // be 0, 1 or 2; for haplotypes it will be 0 or 1

  /**
  The IDs of the variant sets this call set has calls in. These must all belong
  to the same Dataset; a CallSet cannot span Datasets.
  */
  array<string> variantSetIds = [];

  /** The date this call set was created in milliseconds from the epoch. */
  union { null, long } created = null;

  /**
  The time at which this call set was last updated in milliseconds from the
  epoch.
  */
  union { null, long } updated = null;

  /**
  A map of additional call set information.
  */
  map<array<string>> info = {};
}

/**
A Call is an instance of a Vartiant in a CallSet.
*/
record Call {
  /**
  References the ID of the `CallSet` that this `Call` belongs to.
  */
  string callSetId;
  
  /**
  References the ID of the `VariantSet` that this `Call` gets its `Allele`s
  from. All `Allele`s must be in the same `VariantSet`.
  */
  string variantSetId;
  
  /**
  References the IDs of the `Allele`s that this Call reflects the presence of.
  */ 
  array<string> alleleIds;
  
  // HAPLOTYPE-type CallSets double as phase sets, so we don't need phase sets.
  
  // We have various ways of specifying what the call actually is.
  // Not all of the following will be present, but at least one should be
  
  /**
  0 for not present in callSet, 1 for single copy, 2 for 2 copies etc. 
  */
  union { null, int } copyNumber = null; 
  
  /**
  Expected value of copyNumber.
  */
  union { null, float } dosage = null;
  
  /**
  Probability that copy number is k: 0..n
  */ 
  array<float> probability = [];
  
  /**
  Likelihood of data given copy number k.
  */
  array<float> likelihood = []; 
  
  /**
  Number of reads supporting this allele (DP in VCF).
  */
  union { null, int } readCount = null;
  
  /**
  Potential other evidence for the call.
  */
  map<string> evidence = {};
}

/* 
The `Call`s in a `CallSet` are not explicitly ordered and oriented. This
reflects typically the data we have about them. In many cases we can infer order
and orientation from the reference graph on which the `Allele`s are defined, for
example for a sequence of simple variants (SNPs, indels etc) along a
reference.But in the general case with multiple copies of `Allele`s and
rearrangements this is not the case. For when we do want to explicitly state the
order and orientation of `Allele`s we define an `AlleleScaffold` record.

TODO: This is still being worked out; it is not entirely clear how this sort of
phasing ought to interact with haplotype phasing.
*/
record AlleleScaffold {
  /**
  ID of this `AlleleScaffold`.
  */
  string id;

  /**
  ID of the `CallSet` which this `AlleleScaffold` is associated with.
  */
  string callSetId;
  
  /**
  ID of the `VariantSet` which this `AlleleScaffold` is associated with.
  */
  string variantSetId;

  /**
  Array of `Allele` IDs in the order they appear in the scaffold.
  */
  array<string> alleleIds;
  
  /**
  Orientation of each `Allele` (relative to the orientation in which it is
  defined.  
  */
  array<VariantSide> alleleOrientations;
  
  /**
  Sizes of gaps between `Allele`s, array length is 1 less than number of
  `Allele`s.
  */
  array<int> gapSizes = [];   
}

} // end of protocol
