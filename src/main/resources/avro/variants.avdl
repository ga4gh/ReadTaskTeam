@namespace("org.ga4gh.models")
protocol Variants {

import idl "common.avdl";
import idl "references.avdl";

/*
We show how to provide information about samples.  The core idea is to provide
Calls which each contain information about the presence or absence of a set of
`Variant`s (as a group) in a `CallSet` (which can be a chromosome or a sample).
Loosely, the variant sets correspond to rows in a VCF and the callsets to a
column, but there are some key differences.

First, we provide information about alleles that may or may not exist in a call
set, and not sites at which a call set chooses between available alleles, since
we are using the "unary" or "monoallelic" variant model, in which a variant is a
single allele that may or may not be present in some copy number. We can
determine from the graph whether two variants or sets of variants are
incompatible in the same haplotype and hence "allelic" in the standard usage of
the term.  Note that this is a pairwise relation, not transitive. This avoids
the problems when merging sites in VCF. Our merge semantics are simple: only
merge identical variant sets. Identity can be checked by name when sharing a
global name and definition space, or recursively by how the variants are
constructed from global objects when scope is local.

Second, we represent phase information by separate haplotype callSets, rather
than using some sort of | or / notation or equivalent in the calls of a genotype
callSet. So genotype callSets just contain variant counts (copy number) or
dosages. Because we support sparse callSets, which we hope can be lightweight,
each piece of partial haplotype phasing (as for example supported by phase sets
in VCF) will be a separate haplotype CallSet on the same sample. Since phasing
onto haplotypes can still be ambiguous in the case of complex duplications and
transpositions, we also provide a notion of Scaffolds which are ordered,
oriented, gapped lists of Variants that are asserted to appear on the same
molecule.
*/

/**
This metadata represents VCF header information.
*/
record VariantSetMetadata {
  /** The top-level key. */
  string key;

  /** The value field for simple metadata. */
  string value;

  /**
  User-provided ID field, not enforced by this API.
  Two or more pieces of structured metadata with identical
  id and key fields are considered equivalent.
  */
  string id;

  /** The type of data. */
  string type;

  /**
  The number of values that can be included in a field described by this
  metadata.
  */
  string number;

  /** A textual description of this metadata. */
  string description;

  /** Remaining structured metadata key-value pairs. */
  map<array<string>> info = {};
}

/**
`Variant`s belong to `VariantSet`s. A `CallSet` has calls in a `VariantSet`.
Some novel `Reference`s can belong to `VariantSet`s (while other belong to
`ReferenceSet`s). A `VariantSet` belongs to a `Dataset`.
The variant set is equivalent to a VCF file.
*/
record VariantSet {
  /** The variant set ID. */
  string id;

  /** The ID of the dataset this variant set belongs to. */
  string datasetId;

  /**
  The reference set the variants in this variant set are using.
  */
  string referenceSetId;

  /**
  The metadata associated with this variant set. This is equivalent to
  the VCF header information not already presented in first class fields.
  */
  array<VariantSetMetadata> metadata = [];
}

/**
Some CallSets reflect genotype calls, while others reflect linked haplotype
calls.
*/
enum CallSetType {
  GENOTYPE,
  HAPLOTYPE
}

/**
A `CallSet` is a collection of variant calls for a particular sample.
It belongs to a `VariantSet`. This is equivalent to one column in VCF.
*/
record CallSet {

  /** The call set ID. */
  string id;

  /** The call set name. */
  union { null, string } name = null;

  /** The sample this call set's data was generated from. */
  union { null, string } sampleId;

  /**
  A `CallSet` must be either a genotype or a haplotype. This field specifies
  which. A HAPLOTYPE-type `CallSet` is just a bag of `Call`s on the same piece
  of DNA; there may be more than one way to traverse the graph as a single
  haplotype.
  */
  CallSetType callsetType;

  // For diploid genotypes the copy number of a set of Variants in a Call will
  // typically be 0, 1 or 2; for haplotypes it will be 0 or 1

  /** The IDs of the variant sets this call set has calls in. */
  array<string> variantSetIds = [];

  /** The date this call set was created in milliseconds from the epoch. */
  union { null, long } created = null;

  /**
  The time at which this call set was last updated in
  milliseconds from the epoch.
  */
  union { null, long } updated = null;

  /**
  A map of additional call set information.
  */
  map<array<string>> info = {};
}

/**
A `Call` represents the determination of genotype with respect to a
particular variant. It may include associated information such as quality
and phasing. For example, a call might assign a probability of 0.32 to
the occurrence of a SNP named rs1234 in a call set with the name NA12345.
*/
record Call {

  /**
  The ID of the call set this variant call belongs to.
  */
  union { null, string } callSetId;

  /**
  The name of the call set this variant call belongs to.
  */
  union { null, string } callSetName = null;

  /**
  The IDs of the `Variant`s that this Call reflects the presence of.
  */
  array<string> variantIds;

  // HAPLOTYPE-type CallSets double as phase sets, so we don't need phase sets.

  // We have various ways of specifying what the call actually is.
  // Not all of the following will be present, but at least one should be

  /**
  0 for not present in callSet, 1 for single copy, 2 for 2 copies etc.
  */
  union { null, int } copyNumber = null;

  /**
  Expected value of copyNumber.
  */
  union { null, float } dosage = null;

  /**
  Probability that copy number is k: 0..n
  */
  array<float> probability = [];

  /**
  Likelihood of data given copy number k.
  */
  array<float> likelihood = [];

  /**
  Number of reads supporting this variant (DP in VCF).
  */
  union { null, int } readCount = null;

  /**
  Potential other evidence for the call.
  */
  map<string> evidence = {};

  /**
  A map of additional variant call information.
  */
  map<array<string>> info = {};
}

/**
`Variant`s are "monoallelic": they are not places at which any of a number of
alleles may occur, but rather single alleles that are present in some copy
number.

A `Variant` is a contigous piece of sequence that we will want to say is present
(in general at some copy number) or absent in a sample. Very often it will just
be a single segment covering the entirety of a novel `Reference`, but it is also
common for it to be a `Segment` of a `Reference` not overlapped by another
`Variant`'s `Segment`s, or in general to be any contiguous path through the
sequence graph of `Reference`s.

`Variant`s belong to `VariantSet`s.

Remember that `Path`s cannot follow adjacencies not represented in the
`Reference`s they use. If you want a `Variant` that spans a novel deletion, say,
you must include a new `Reference` in your `VariantSet` providing that
adjacency, which your `Variant` can then follow.
*/
record Variant {
  /**
  The ID of this `Variant`. If this Variant is one segment consisting of the
  entirety of a `Reference`, this is equal to the ID of that `Reference`.
  */
  string id;

  /** The ID of the variant set this variant belongs to. */
  string variantSetId;

  /**
  The time at which this variant was last updated in
  milliseconds from the epoch.
  */
  union { null, long } updated = null;

  /**
  What `Segment`s of what `Reference`s in what order constitute this `Variant`?

  Note that a `Segment` in this `Path` that is 0-length represents the adjacency
  immediately before the named base.
  */
  Path path;
}

/**
The `Call`s in a `CallSet` are not explicitly ordered and oriented. This
reflects typically the data we have about them. In many cases we can infer order
and orientation from the reference graph on which the `Variant`s are defined, for
example for a sequence of simple variants (SNPs, indels etc) along a reference.
But in the general case with multiple copies of `Variant`s and rearrangements
this is not the case. For when we do want to explicitly state the order and
orientation of `Variant`s we define a `VariantScaffold` record.

TODO: This is still being worked out; it is not entirely clear how this sort of
phasing ought to interact with haplotype phasing.
*/
record VariantScaffold {
  /**
  ID of this `VariantScaffold`.
  */
  string id;

  /**
  ID of the `CallSet` which this `VariantScaffold` is associated with.
  */
  string callSetId;

  /**
  ID of the `VariantSet` which this `VariantScaffold` is associated with.
  */
  string variantSetId;

  /**
  Array of `Variant` IDs in the order they appear in the scaffold.
  */
  array<string> variantIds;

  /**
  Orientation of each `Variant` (relative to the orientation in which it is
  defined.
  */
  array<ReferenceSide> variantOrientations;

  /**
  Sizes of gaps between `Variant`s, array length is 1 less than number of
  `Variant`s.
  */
  array<int> gapSizes = [];
}

// `Reference`s as defined in references.avdl are also used to represent novel
// variant sequence here.

}
