@namespace("org.ga4gh.models")
protocol Variants {

import idl "common.avdl";
import idl "references.avdl";

/*
We show how to provide information about samples.  The core idea is to provide
Calls which each contain information about the presence or absence of a set of
`Allele`s (as a group) in a `CallSet` (which can be a chromosome or a sample).
Loosely, the variant sets correspond to rows in a VCF and the callsets to a
column, but there are some key differences.

First, we provide information about alleles that may or may not exist in a call
set, and not sites at which a call set chooses between available alleles, since
we are using the "unary" or "allelic" variant model, in which we describe
variation with single alleles that may or may not be present in some copy
number. We can determine from the graph whether two alleles or sets of alleles
are incompatible in the same haplotype and hence "allelic" in the standard usage
of the term.  Note that this is a pairwise relation, not transitive. This avoids
the problems when merging sites in VCF. Our merge semantics are simple: only
merge identical variant sets. Identity can be checked by name when sharing a
global name and definition space, or recursively by how the alleles are
constructed from global objects when scope is local.

Second, we represent phase information by separate haplotype callSets, rather
than using some sort of | or / notation or equivalent in the calls of a genotype
callSet. So genotype callSets just contain allele counts (copy number) or
dosages. Because we support sparse callSets, which we hope can be lightweight,
each piece of partial haplotype phasing (as for example supported by phase sets
in VCF) will be a separate haplotype CallSet on the same sample. Since phasing
onto haplotypes can still be ambiguous in the case of complex duplications and
transpositions, we also provide a notion of Scaffolds which are ordered,
oriented, gapped lists of `Allele`s that are asserted to appear on the same
molecule.
*/

/**
This metadata represents VCF header information.
*/
record VariantSetMetadata {
  /** The top-level key. */
  string key;

  /** The value field for simple metadata. */
  string value;

  /**
  User-provided ID field, not enforced by this API.
  Two or more pieces of structured metadata with identical
  id and key fields are considered equivalent.
  */
  string id;

  /** The type of data. */
  string type;

  /**
  The number of values that can be included in a field described by this
  metadata.
  */
  string number;

  /** A textual description of this metadata. */
  string description;

  /** Remaining structured metadata key-value pairs. */
  map<array<string>> info = {};
}

/**
`Allele`s belong to `VariantSet`s. A `CallSet` has calls in a `VariantSet`. Some
novel `Segment`s can belong to `VariantSet`s. A `VariantSet` belongs to a
`Dataset`. The variant set is equivalent to a VCF file.
*/
record VariantSet {
  /** The variant set ID. */
  string id;

  /** The ID of the dataset this variant set belongs to. */
  string datasetId;

  /**
  The reference set the variants in this variant set are using.
  */
  string referenceSetId;

  /**
  The metadata associated with this variant set. This is equivalent to
  the VCF header information not already presented in first class fields.
  */
  array<VariantSetMetadata> metadata = [];
}

/**
Some CallSets reflect genotype calls, while others reflect linked haplotype
calls.
*/
enum CallSetType {
  GENOTYPE,
  HAPLOTYPE
}

/**
A `CallSet` is a collection of variant calls for a particular sample. `CallSet`s
hold `Call`s for a sample, or one of a sample's haplotypes, in one or more
`VariantSet`s. This is roughly equivalent to one column in VCF.
*/
record CallSet {

  /** The call set ID. */
  string id;

  /** The call set name. */
  union { null, string } name = null;

  /** The sample this call set's data was generated from. */
  union { null, string } sampleId;

  /**
  A `CallSet` must be either a genotype or a haplotype. This field specifies
  which. A HAPLOTYPE-type `CallSet` is just a bag of `Call`s on the same piece
  of DNA; there may be more than one way to traverse the graph as a single
  haplotype.
  */
  CallSetType callsetType;

  // For diploid genotypes the copy number of a set of `Allele`s in a `Call` will
  // typically be 0, 1 or 2; for haplotypes it will be 0 or 1

  /** The IDs of the variant sets this call set has calls in. */
  array<string> variantSetIds = [];

  /** The date this call set was created in milliseconds from the epoch. */
  union { null, long } created = null;

  /**
  The time at which this call set was last updated in
  milliseconds from the epoch.
  */
  union { null, long } updated = null;

  /**
  A map of additional call set information.
  */
  map<array<string>> info = {};
}

/**
Represents a `Genotype` integrating over the `Call`s belonging to a particular
`Variant` in a `CallSet`. Analogous to a `Variant`-level `Call`, as might be
found in VCF.

Mostly useful for importing VCF annotations, or for giving joint distributions
on copy numbers of different `Call`s referencing a `Variant` (like genotype
likelihoods).
*/
record Genotype {

  /**
  The ID of the call set this `Genotype` belongs to. Either this field
  or callSetName must be set.
  */
  union { null, string } callSetId;

  /**
  The name of the call set this `Genotype` belongs to. Either this
  field or callSetId must be set.
  */
  union { null, string } callSetName = null;

  /**
  The ID of this `Genotype`. Unique within the repository.
  */
  string id;

  /**
  The ID of the `Variant` that this `Genotype` is expressing the `CallSet`'s
  genotype at.
  */
  string variantId;

  /**
  The total copy number to which the copy numbers of all `Call`s in this
  `Variant` should sum. Can be used to represent assertions about total ploidy
  for an uncertain genotype, such as those present implicitly in VCF.
  */
  union { null, long } totalCopyNumber = null;

  /**
  The genotype likelihoods for this variant call. Each array entry
  represents how likely a specific genotype is for this call as
  log10(P(data | genotype)), analogous to the GL tag in the VCF spec. The
  value ordering is defined by the GL tag in the VCF spec.
  */
  union { null, array<float> } genotypeLikelihoods = null;

  /**
  A map of additional variant call information.
  */
  map<array<string>> info = {};
}

/**
A `Variant` represents a set of alternative `Allele`s that a `Call` can choose
between.

For example, a variant could represent a SNP or an insertion.
Variants belong to a `VariantSet`.
This is equivalent to a row in VCF.

`Call`s on `Variant`s are represented by one `Call` object per `Allele`, with a
reference to the `Variant` to which the `Call` belongs.
*/
record Variant {

  /** The variant ID. */
  string id;

  /** The ID of the variant set this variant belongs to. */
  string variantSetId;

  /** Names for the variant, for example a RefSNP ID. */
  array<string> names = [];

  /** The date this variant was created in milliseconds from the epoch. */
  union { null, long } created = null;

  /**
  The time at which this variant was last updated in
  milliseconds from the epoch.
  */
  union { null, long } updated = null;

  /**
  The `Allele`s available for this `Variant`. The first `Allele` is the
  reference `Allele`, and the rest are alternate `Allele`s.
  */
  array<string> alleleIds;

  /**
  A map of additional variant information.
  */
  map<array<string>> info = {};
}

/**
A `Call` represents the determination of genotype with respect to a
particular `Allele`. It may include associated information such as quality
and phasing. For example, a call might assign a probability of 0.32 to
the occurrence of a SNP named rs1234 in a call set with the name NA12345.
*/
record Call {

  /**
  The ID of the call set this `Call` belongs to.
  */
  union { null, string } callSetId;

  /**
  The name of the call set this `Call` belongs to.
  */
  union { null, string } callSetName = null;

  /**
  The ID of the `Allele` that this `Call` reflects the presence of.
  */
  string alleleId;

  /**
  The ID of the `Variant` in the context of which this `Call` is calling the
  copy number on the `Allele`. The `Allele` called by this `Call` must be on the
  list of `Allele` IDs that are allowable alternatives for the `Variant`. Only
  one `Call` in a `CallSet` can describe a given `Allele` within a particular
  `Variant`.
  */
  union { null, string } variantId = null;

  // HAPLOTYPE-type CallSets double as phase sets, so we don't need phase sets.

  // We have various ways of specifying what the call actually is.
  // Not all of the following will be present, but at least one should be

  /**
  Called integer copy number for this `Allele` in this `CallSet`. 0 for not
  present in `CallSet`, 1 for single copy, 2 for 2 copies, etc.
  */
  union { null, int } copyNumber = null;

  /**
  Stores the expected value of the true number of copies of the `Allele` in the
  `CallSet`.
  */
  union { null, float } dosage = null;

  /**
  Holds an array of floats, where each is the probability that the copy number
  of the `Allele` in the `CallSet` is equal to that 0-based index in the array.
  If the array is present and its values do not sum to 1, the remaining
  probability is the probability that the copy number is not any of the values
  for which probabilities are present.
  */
  union { null, array<float> } probability = null;

  /**
  Holds an array of floats, where each is the likelihood of the data given that
  the copy number of the `Allele` in the `CallSet` is equal to that 0-based
  index in the array.
  */
  union { null, array<float> } likelihood = null;

  /**
  Number of reads supporting this allele (DP in VCF).
  */
  union { null, int } readCount = null;

  /**
  A map of additional allele call information.
  */
  map<array<string>> info = {};
}

/**
`Allele`s are the key component of the "allelic" model of variation: they are
single objects that are present in some copy number.

An `Allele` is a contigous piece of sequence that we will want to say is present
(in general at some copy number) or absent in a sample. Very often it will just
be a single `Subsegment` covering the entirety of a novel `Segment`, but it is
also common for it to be a `Subsegment` of a `Segment` not overlapped by
another `Allele`'s `Subsegment`s, or in general to be any contiguous path
through the sequence graph of `Segment`s.

`Allele`s belong to `VariantSet`s.

Note that `Path`s cannot follow adjacencies not represented in the `Segment`s
they use. If  an `Allele` that spans a novel deletion is required, for example,
a new `Segment` must be included in the `VariantSet` providing that adjacency,
which this `Allele` can then follow.
*/
record Allele {
  /**
  The ID of this `Allele`. If this `Allele` is one `Subsegment` consisting of
  the entirety of a `Segment`, this is equal to the ID of that `Segment`.
  */
  string id;

  /** The ID of the variant set this allele belongs to. */
  string variantSetId;

  /**
  The time at which this `Allele` was last updated in
  milliseconds from the epoch.
  */
  union { null, long } updated = null;

  /**
  The ordered and oriented `Subsegment`s of DNA that this `Allele` represents.
  Note that a `Subsegment` in this `Path` that is 0-length represents the
  adjacency immediately before the named base.
  */
  Path path;
}

/**
The `Call`s in a `CallSet` are not explicitly ordered and oriented. This
reflects typically the data we have about them. In many cases we can infer order
and orientation from the `ReferenceSet` graph on which the `Allele`s are
defined, for example for a sequence of simple variants (SNPs, indels etc) along
a `Reference`. But in the general case with multiple copies of `Allele`s and
rearrangements this is not the case. When we do want to explicitly state the
order and orientation of `Allele`s, we define an `AlleleScaffold` record.

TODO: This is still being worked out; it is not entirely clear how this sort of
phasing ought to interact with haplotype phasing.
*/
record AlleleScaffold {
  /**
  ID of this `AlleleScaffold`.
  */
  string id;

  /**
  ID of the `CallSet` which this `AlleleScaffold` is associated with.
  */
  string callSetId;

  /**
  ID of the `VariantSet` which this `AlleleScaffold` is associated with.
  */
  string variantSetId;

  /**
  Array of `Allele` IDs in the order they appear in the scaffold.
  */
  array<string> alleleIds;

  /**
  Orientation of each `Allele` (relative to the orientation in which it is
  defined.
  */
  array<SegmentSide> alleleOrientations;

  /**
  Sizes of gaps between `Allele`s, array length is 1 less than number of
  `Allele`s.
  */
  array<int> gapSizes = [];
}

// `Segment`s as defined in references.avdl are also used to represent novel
// allele sequence here.

}
